# -*- coding: utf-8 -*-
"""Recomendador_de_musicas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ddknc-TGRCbCJxu7VHp8IjBw4Nc2kyvY

##Aula 1.4 Análise dos dados
"""

import pandas as pd
import numpy as np

dados = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Alura/Clustering aplicado: recomendando músicas com  k-Means/2604-dados/Dados/Dados_totais.csv")
dados_generos = pd.read_csv ("/content/drive/MyDrive/Colab Notebooks/Alura/Clustering aplicado: recomendando músicas com  k-Means/2604-dados/Dados/data_by_genres.csv")
dados_anos = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Alura/Clustering aplicado: recomendando músicas com  k-Means/2604-dados/Dados/data_by_year.csv")

dados.head(2)

dados["year"].unique()

dados.shape

dados = dados.drop(["explicit", "key", "mode"], axis=1)
dados.head(2)

dados.shape

dados.isnull().sum()

dados.isna().sum()

dados_generos.head(2)

dados_generos = dados_generos.drop(["key", "mode"], axis=1)
dados_generos.head(2)

dados_anos["year"].unique()

dados_anos = dados_anos[dados_anos["year"]>=2000]
dados_anos["year"].unique()

dados_anos = dados_anos.drop(["key", "mode"], axis=1)
dados_anos.head(2)

dados_anos.reset_index()

"""# Análise gráfica

usando: plotly express
"""

import plotly.express as px

fig = px.line(dados_anos, x = "year", y = "loudness", markers = True, title = "Variação do loudness conforme os anos")
fig.show()

import plotly.graph_objects as go

fig = go.Figure()

fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['acousticness'],
                         name ='Acousticness'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['valence'],
                         name ='Valence'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['danceability'],
                         name ='Danceability'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['energy'],
                         name ='Energy'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['instrumentalness'],
                         name ='Instrumentalness'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['liveness'],
                         name ='Liveness'))
fig.add_trace(go.Scatter(x=dados_anos['year'], y = dados_anos ['speechiness'],
                         name ='Speechiness'))
fig.show()

fig = px.imshow(dados.corr(), text_auto=True)
fig.show()

"""# Aula 2 - Clasterização por gênero

##Aula 2.1 - PCA e SdandardScaler
"""

dados_generos

dados_generos['genres'].value_counts().sum()

dados_generos1 = dados_generos.drop('genres', axis=1)
dados_generos1

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

SEED = 1224
np.random.seed(1224)

pca_pipeline = Pipeline([('scaler', StandardScaler()), ('PCA', PCA(n_components=2, random_state=SEED))])

genre_embedding_pca = pca_pipeline.fit_transform(dados_generos1)
projection = pd.DataFrame(columns=['x','y'], data=genre_embedding_pca)

projection

"""## Aula 2.2 KMeans"""

from sklearn.cluster import KMeans

kmeans_pca = KMeans(n_clusters=5, verbose=True, random_state=SEED)

kmeans_pca.fit(projection)

dados_generos['cluster_pca'] = kmeans_pca.predict(projection)
projection['cluster_pca'] = kmeans_pca.predict(projection)

projection['generos'] = dados_generos['genres']

projection

"""## Aula 2.3 Plotando a clusternig

"""

fig = px.scatter(
    projection, x='x',y='y', color='cluster_pca', hover_data=['x', 'y', 'generos'])
fig.show()

pca_pipeline[1].explained_variance_ratio_

pca_pipeline[1].explained_variance_ratio_.sum()

pca_pipeline[1].explained_variance_

pca_pipeline[1].explained_variance_ratio_.sum()

"""## Aula 3 - Clusters por músicas

Aula 3.1 Redução de dimensionalidade com PCA
"""

dados.head()

dados['artists'].value_counts()

dados['artists_song'].value_counts()

from sklearn.preprocessing import OneHotEncoder

ohe = OneHotEncoder(dtype=int)
colunas_ohe = ohe.fit_transform(dados[['artists']]).toarray()
dados2 = dados.drop('artists', axis=1)

dados_musicas_dummies = pd.concat([dados2, pd.DataFrame(colunas_ohe, columns=ohe.get_feature_names_out(['artists']))], axis=1)
dados_musicas_dummies

pca_pipeline = Pipeline([('scaler', StandardScaler()), ('PCA', PCA(n_components=0.7, random_state=SEED))])

music_embedding_pca = pca_pipeline.fit_transform(dados_musicas_dummies.drop(['id', 'name', 'artists_song'], axis=1))
projection_m = pd.DataFrame(data=music_embedding_pca)

pca_pipeline[1].n_components_

"""# Aula 3.2 Aplicação do cluster com K-means"""

kmeans_pca_pipeline = KMeans(n_clusters=50, verbose=False, random_state=SEED)

kmeans_pca_pipeline.fit(projection_m)

dados['cluster_pca'] = kmeans_pca_pipeline.predict(projection_m)
projection_m['cluster_pca'] = kmeans_pca_pipeline.predict(projection_m)

projection_m['artist'] = dados['artists']
projection_m['song'] = dados['artists_song']

projection_m

"""# Aula 3.3 Analisando a clustering"""

fig = px.scatter_3d(
    projection_m, x=0,y=1,z=2, color='cluster_pca', hover_data=[ 0, 1, 'song'])
fig.show()

pca_pipeline[1].explained_variance_ratio_.sum()

pca_pipeline[1].explained_variance_.sum()

"""# Aula 4 - Sistema de Recomendação

##  Aula 4.1 Recomendação da música
"""

nome_musica = 'Linkin Park - In the End'

from pandas.core.dtypes.cast import maybe_upcast
from sklearn.metrics.pairwise import euclidean_distances

cluster = list(projection_m[projection_m['song']== nome_musica]['cluster_pca'])[0]
musicas_recomendadas = projection_m[projection_m['cluster_pca']==cluster][[0,1,'song']]
x_musica = list(projection_m[projection_m['song']== nome_musica][0])[0]
y_musica = list(projection_m[projection_m['song']== nome_musica][1])[0]

# distâncias Euclidianas 
distancias = euclidean_distances(musicas_recomendadas[[0,1]], [[x_musica, y_musica]])
musicas_recomendadas['id'] = dados['id']
musicas_recomendadas['distancias'] = distancias
recomendada = musicas_recomendadas.sort_values('distancias').head(10)
recomendada

projection_m.head()

cluster = list(projection_m[projection_m['song']== nome_musica]['cluster_pca'])[0]
print(cluster)

"""##Aula 4.2 Biblioteca Spotipy

Spotify for Developers
"""

!pip install spotipy

import spotipy
from spotipy.oauth2 import SpotifyOAuth
from spotipy.oauth2 import SpotifyClientCredentials

"""##Atenção 

Antes de rodar essa parte do código. você precisa fazer uma conta na API do spotify e gerar suas próprias client_id e client_secret
"""

scope = "user-library-read playlist-modify-private"
OAuth = SpotifyOAuth(
        scope=scope,
        redirect_uri='http://locathost:8888/callback',
        client_id= '5f0c00f0de6943d9a754619318e3436e',
        client_secret= '0d076f1b1b254871b555dc55f362cf38'
 )

client_credentials_manager = SpotifyClientCredentials(client_id = '5f0c00f0de6943d9a754619318e3436e', client_secret = '0d076f1b1b254871b555dc55f362cf38')
sp = spotipy.Spotify(client_credentials_manager = client_credentials_manager)

"""# Aula 4.3 Imagem do álbum """

import matplotlib.pyplot as plt
from skimage import io

# localizando o ID
nome_musica = 'Eminem - The Real Slim Shady'
id = dados[dados['artists_song'] == nome_musica]['id'].iloc[0]

# API
track = sp.track(id)
url = track['album']['images'][1]['url']
name = track['name']

# Exibindo a imagem
image = io.imread(url)
plt.imshow(image)
plt.xlabel(name, fontsize = 10)
plt.show

"""# Aula 5 - Recomendador

## Aula 5.1 Buscando os dados da playlist
"""

def recommend_id(playlist_id):
  url = []
  name = []
  for i in playlist_id:
        track = sp.track(i)
        url.append(track["album"]["images"][1]["url"])
        name.append(track["name"])
  return name, url

recommend_id(recomendada['id'])

name, url = recommend_id(recomendada['id'])

"""# Aula 5.2 Gerando as imagens da playlist"""

def visualize_songs(name, url):

  plt.figure(figsize=(15,10))
  columns = 5

  for i, u in enumerate(url):
      # define o ax como o subplot, com a divisão que retorna inteiro do número urls pelas colunas +1 (no caso, 6)
      ax = plt.subplot(len(url)// columns + 1, columns, i + 1)

      # Lendo a imagem com o Scikit Image
      image = io.imread(u)

      # Mostra a imagem
      plt.imshow(image)

      # Para deixar o eixo Y invisível 
      ax.get_yaxis().set_visible(False)

      # xticks define o local que vamos trocar os rótulos do eixo x, nesse caso, deixar os pontos de marcação branco 
      plt.xticks(color = 'w', fontsize = 0.1)

      # xticks define o local que vamos trocar os rótulos do eixo y, nesse caso, deixar os pontos de marcação branco 
      plt.yticks(color = 'w', fontsize = 0.1) 

      # Colocando o nome da música no eixo x
      plt.xlabel(name[i], fontsize = 10)

      # Faz com que todos os parâmetros se encaixem no tamanho da imagem definido 
      plt.tight_layout(h_pad=0.7, w_pad=0)

      # Ajunta os parâmtros de layout da imagem.
      # wspace = a largura do preenchimento entre subparcelas, como uma fração da largura média dos eixos.
      # hspace = A altura do preenchimento entre subparcelas, como uma fração d altura média dos eixos.
      plt.subplots_adjust(wspace=None, hspace=None) 

      # Remove os ticks - marcadores, do eixo x, sem remover o eixo todo, deixando o nome da música.
      plt.tick_params(bottom = False)

      # Tirar a grade da imagem, gerada automaticamente pelo matplotlib
      plt.grid(visible=None)

  plt.show()

visualize_songs(name, url)

"""## Aula 5.3 Fazendo uma função final"""

def recomendador(nome_musica):
  cluster = list(projection_m[projection_m['song']== nome_musica]['cluster_pca'])[0]
  musicas_recomendadas = projection_m[projection_m['cluster_pca']==cluster][[0,1,'song']]
  x_musica = list(projection_m[projection_m['song']== nome_musica][0])[0]
  y_musica = list(projection_m[projection_m['song']== nome_musica][1])[0]

  # distâncias Euclidianas 
  distancias = euclidean_distances(musicas_recomendadas[[0,1]], [[x_musica, y_musica]])
  musicas_recomendadas['id'] = dados['id']
  musicas_recomendadas['distancias'] = distancias
  recomendada = musicas_recomendadas.sort_values('distancias').head(10)
  
# Acessando os dados de cada música com a biblioteca Spotipy (nome e imagem)
playlist_id = recomendada['id']

url = []
name = []
for i in playlist_id:
  track = sp.track(i)
  url.append(track["album"]["images"][1]["url"])
  name.append(track["name"])

# Plotando as figuras 

plt.figure(figsize=(15,10))
columns = 5
for i, u in enumerate(url):
  ax = plt.subplot(len(url)// columns + 1, columns, i + 1)
  image = io.imread(u)
  plt.imshow(image)
  ax.get_yaxis().set_visible(False)
  plt.xticks(color = 'w', fontsize = 0.1)
  plt.yticks(color = 'w', fontsize = 0.1)
  plt.xlabel(name[i], fontsize = 10)
  plt.tight_layout(h_pad=0.7, w_pad=0)
  plt.subplots_adjust(wspace=None, hspace=None)
  plt.tick_params(bottom = False)
  plt.grid(visible=None)

recomendador('Coldplay - Yellow')